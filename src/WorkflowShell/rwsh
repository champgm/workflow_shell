#!/usr/bin/env ruby

# This will allow us to parse options nicely
require 'optparse'

# This line figures out where this script lives
@script_home = File.expand_path(File.dirname(__FILE__))
# This line will search all subdirectories for *.rb files and import them
Dir[@script_home + '/*/*.rb'].each {|file| require_relative file }

# Retrieve all subclasses of Command
@command_classes = Command.descendants.each { |command_class| command_class.new }

# Instantiate each command class and map each instance to its command string
@command_map = Hash[@command_classes.map { |command_class|
  instantiated_command = command_class.new
  command_string       = instantiated_command.get_command_string
  [command_string, instantiated_command]
}]

# This is a general spacing/width size. If things look too spread out or to close together, change it.
@column_width = 22

def run_command(command_string, arguments)
  puts @command_map
  command_instance = @command_map[command_string]
  command_instance.run_command(arguments)
end

def print_help
  @command_map.each do |command|
    # command will be of the format [command_string, command_instance]
    command_string = command.at(0)
    command_description = command.at(1).get_command_description

    puts (padding(@column_width) +
        command_string +
        padding(@column_width - command_string.length) +
        command_description)
  end
end

# A util method for creating "x" amount of spaces
def padding(x)
  spaces = ''
  (0...x).each { |i|
    spaces += ' '
  }
  spaces
end

# This is the actual script that will run.
if ARGV.length < 1 || (ARGV.length == 1 && (ARGV.at(0) == "-h" || ARGV.at(0) == "help"))
  print_help
else
  # Separate the command string from the arguments.
  command_string = ARGV.at(0)
  rest_of_arguments = ARGV.drop(1)
  puts command_string
  puts rest_of_arguments

  # Run the command
  run_command(command_string, rest_of_arguments)
end